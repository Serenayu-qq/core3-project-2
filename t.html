<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Finding Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            cursor: grab;
            position: relative;
            z-index: 1;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.75);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            max-width: 320px;
            z-index: 100;
        }

        .info-panel h3 {
            margin-bottom: 12px;
            font-size: 18px;
            font-weight: 600;
        }

        .info-panel p {
            margin: 8px 0;
            font-size: 14px;
            line-height: 1.6;
            opacity: 0.9;
        }

        .score {
            font-size: 20px;
            font-weight: bold;
            color: #4ecdc4;
            margin-top: 10px;
        }

        .color-scores {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .color-score-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 14px;
        }

        .color-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .color-name {
            flex: 1;
        }

        .color-count {
            font-weight: bold;
            color: #fff;
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modal.active {
            display: flex;
            opacity: 1;
        }

        .modal-content {
            background: #fff;
            border-radius: 16px;
            padding: 40px;
            max-width: 500px;
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .modal.active .modal-content {
            transform: scale(1);
        }

        .modal-title {
            font-size: 28px;
            font-weight: 700;
            color: #222;
            margin-bottom: 16px;
        }

        .modal-description {
            font-size: 16px;
            color: #666;
            line-height: 1.8;
            margin-bottom: 24px;
        }

        .found-message {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .close-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            border: none;
            padding: 14px 40px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .close-btn:hover {
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div class="info-panel">
        <h3>ğŸ¨ Color Finding Game</h3>
        <p>ğŸ” Find and click the hidden spheres</p>
        <p>ğŸ–±ï¸ Drag to rotate the scene</p>
        <p>ğŸ‘† Click spheres to reveal colors</p>
        <div class="score">Total Found: <span id="score">0</span> / <span id="total">22</span></div>
        <div class="color-scores" id="colorScores"></div>
    </div>

    <div id="canvas-container"></div>

    <div id="modal" class="modal">
        <div class="modal-content">
            <div class="found-message">ğŸ‰ Color Found!</div>
            <h2 id="modal-title" class="modal-title"></h2>
            <p id="modal-description" class="modal-description"></p>
            <button class="close-btn">Continue</button>
        </div>
    </div>

    <div id="completion-modal" class="completion-modal">
        <div class="completion-content">
            <div class="completion-title">ğŸ‰ Congratulations! ğŸ‰</div>
            <div class="completion-message">You found all 22 colors!</div>
            <button class="restart-btn">Restart Game</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';

        // æ¸¸æˆé…ç½®
        const CONFIG = {
            background: {
                image: 'background.jpg',  // è®¾ç½®ä¸º null ä½¿ç”¨é»˜è®¤æ˜Ÿç©ºèƒŒæ™¯
                type: 'sphere',           
                scale: 0.5,               // ä»…å¯¹å¹³é¢èƒŒæ™¯ç”Ÿæ•ˆ
                enableFullRotation: true
            }
        };

        const SPHERES = [
            // 1ä¸ªè“è‰²
            { id: 'blue1', title: 'Sky', description: 'The sky looks blue because sunlight is made of many colors, and the blue light waves are scattered in all directions by the gases and particles in the air. This scattering, called Rayleigh scattering, makes the blue light spread more than other colors, so we see a blue sky during the day.', position: { x: 2, y: 14, z: -5 }, radius: 0.5, color: 0x51c4f5, category: 'blue', name: 'è“è‰²' },
            
            // 6ä¸ªç»¿è‰²
            { id: 'green1', title: 'ç¿¡ç¿ ç»¿', description: 'å¦‚ç¿¡ç¿ èˆ¬çè´µçš„ç»¿è‰²ï¼Œå……æ»¡ç”Ÿæœºä¸å¸Œæœ›', position: { x: 3, y: 1, z: -4 }, radius: 0.45, color: 0x00ff00, category: 'green', name: 'ç»¿è‰²' },
            { id: 'green2', title: 'æ£®æ—ç»¿', description: 'èŒ‚å¯†æ£®æ—çš„é¢œè‰²ï¼Œå¸¦æ¥å¤§è‡ªç„¶çš„æ¸…æ–°æ°”æ¯', position: { x: -3, y: 0, z: -6 }, radius: 0.4, color: 0x228b22, category: 'green', name: 'ç»¿è‰²' },
            { id: 'green3', title: 'è–„è·ç»¿', description: 'æ¸…å‡‰çš„è–„è·ç»¿ï¼Œè®©äººæ„Ÿåˆ°èˆ’é€‚å’Œæ”¾æ¾', position: { x: 1, y: -2, z: -5 }, radius: 0.5, color: 0x98fb98, category: 'green', name: 'ç»¿è‰²' },
            { id: 'green4', title: 'æ©„æ¦„ç»¿', description: 'æˆç†Ÿçš„æ©„æ¦„ç»¿ï¼Œè±¡å¾ç€å’Œå¹³ä¸æ™ºæ…§', position: { x: -2, y: 3, z: -7 }, radius: 0.42, color: 0x6b8e23, category: 'green', name: 'ç»¿è‰²' },
            { id: 'green5', title: 'é’è‰ç»¿', description: 'æ˜¥å¤©é’è‰çš„é¢œè‰²ï¼Œå……æ»¡æ´»åŠ›ä¸æœæ°”', position: { x: 4, y: -1, z: -6 }, radius: 0.48, color: 0x7cfc00, category: 'green', name: 'ç»¿è‰²' },
            { id: 'green6', title: 'æ¾çŸ³ç»¿', description: 'å¦‚æ¾çŸ³èˆ¬ä¼˜é›…çš„ç»¿è‰²ï¼Œå¸¦æœ‰ä¸€ä¸è“è‰²çš„ç¥ç§˜', position: { x: -1, y: -3, z: -4 }, radius: 0.46, color: 0x40e0d0, category: 'green', name: 'ç»¿è‰²' },
            
            // 4ä¸ªçº¢è‰²
            { id: 'red1', title: 'çƒˆç„°çº¢', description: 'å¦‚ç«ç„°èˆ¬ç‚½çƒ­çš„çº¢è‰²ï¼Œå……æ»¡æ¿€æƒ…ä¸åŠ›é‡', position: { x: 2, y: 2, z: -5 }, radius: 0.5, color: 0xff0000, category: 'red', name: 'çº¢è‰²' },
            { id: 'red2', title: 'ç«ç‘°çº¢', description: 'æµªæ¼«çš„ç«ç‘°çº¢ï¼Œè±¡å¾ç€çˆ±æƒ…ä¸ç¾å¥½', position: { x: -4, y: 1, z: -5 }, radius: 0.44, color: 0xff1493, category: 'red', name: 'çº¢è‰²' },
            { id: 'red3', title: 'æœ±ç ‚çº¢', description: 'ä¼ ç»Ÿçš„æœ±ç ‚çº¢ï¼Œå¸¦æœ‰ä¸œæ–¹çš„ç¥ç§˜æ°”æ¯', position: { x: 0, y: -1, z: -7 }, radius: 0.47, color: 0xdc143c, category: 'red', name: 'çº¢è‰²' },
            { id: 'red4', title: 'æ¨±æ¡ƒçº¢', description: 'ç”œç¾çš„æ¨±æ¡ƒçº¢ï¼Œå¦‚åŒå¤æ—¥çš„æœå®èˆ¬è¯±äºº', position: { x: 3, y: -2, z: -6 }, radius: 0.43, color: 0xff4500, category: 'red', name: 'çº¢è‰²' },
            
            // 4ä¸ªé»‘è‰²
            { id: 'black1', title: 'åˆå¤œé»‘', description: 'å¦‚åˆå¤œèˆ¬æ·±æ²‰çš„é»‘è‰²ï¼Œå……æ»¡ç¥ç§˜ä¸æœªçŸ¥', position: { x: -3, y: -2, z: -5 }, radius: 0.5, color: 0x1a1a1a, category: 'black', name: 'é»‘è‰²' },
            { id: 'black2', title: 'å¢¨ç‰é»‘', description: 'å¦‚å¢¨ç‰èˆ¬æ·±é‚ƒçš„é»‘è‰²ï¼Œä¼˜é›…è€Œé«˜è´µ', position: { x: 2, y: -3, z: -7 }, radius: 0.45, color: 0x0f0f0f, category: 'black', name: 'é»‘è‰²' },
            { id: 'black3', title: 'æš—å¤œé»‘', description: 'æš—å¤œçš„é¢œè‰²ï¼Œå®é™è€Œæ·±é‚ƒ', position: { x: -2, y: 4, z: -6 }, radius: 0.48, color: 0x2a2a2a, category: 'black', name: 'é»‘è‰²' },
            { id: 'black4', title: 'ä¹Œæœ¨é»‘', description: 'ä¹Œæœ¨çš„æ·±é»‘è‰²ï¼ŒåšéŸ§è€Œæ°¸æ’', position: { x: 4, y: 2, z: -8 }, radius: 0.46, color: 0x151515, category: 'black', name: 'é»‘è‰²' },
            
            // 7ä¸ªé»„è‰²
            { id: 'yellow1', title: 'é‡‘è‰²é˜³å…‰', description: 'å¦‚é˜³å…‰èˆ¬ç¿çƒ‚çš„é‡‘é»„è‰²ï¼Œæ¸©æš–è€Œæ˜äº®', position: { x: 1, y: 3, z: -5 }, radius: 0.5, color: 0xffd700, category: 'yellow', name: 'é»„è‰²' },
            { id: 'yellow2', title: 'æŸ æª¬é»„', description: 'æ¸…æ–°çš„æŸ æª¬é»„ï¼Œå……æ»¡æ´»åŠ›ä¸æœæ°”', position: { x: -1, y: 1, z: -4 }, radius: 0.44, color: 0xffff00, category: 'yellow', name: 'é»„è‰²' },
            { id: 'yellow3', title: 'ç¥ç€é»„', description: 'å¦‚ç¥ç€èˆ¬æ¸©æ¶¦çš„é»„è‰²ï¼Œå¤è€è€Œçè´µ', position: { x: 3, y: -1, z: -7 }, radius: 0.47, color: 0xffbf00, category: 'yellow', name: 'é»„è‰²' },
            { id: 'yellow4', title: 'èŠ¥æœ«é»„', description: 'ç‹¬ç‰¹çš„èŠ¥æœ«é»„ï¼Œå¸¦æœ‰ä¸€ä¸å¤å¤çš„éŸµå‘³', position: { x: -4, y: -1, z: -6 }, radius: 0.45, color: 0xe1ad01, category: 'yellow', name: 'é»„è‰²' },
            { id: 'yellow5', title: 'é¹…é»„', description: 'æ¸©æŸ”çš„é¹…é»„è‰²ï¼Œå¦‚åŒæ˜¥æ—¥çš„æ¸©æš–é˜³å…‰', position: { x: 0, y: 4, z: -7 }, radius: 0.43, color: 0xfff68f, category: 'yellow', name: 'é»„è‰²' },
            { id: 'yellow6', title: 'å‘æ—¥è‘µé»„', description: 'å‘æ—¥è‘µçš„æ˜äº®é»„è‰²ï¼Œå……æ»¡å¸Œæœ›ä¸æ´»åŠ›', position: { x: 2, y: 0, z: -8 }, radius: 0.49, color: 0xffda00, category: 'yellow', name: 'é»„è‰²' },
            { id: 'yellow7', title: 'èœ‚èœœé»„', description: 'å¦‚èœ‚èœœèˆ¬ç”œç¾çš„é»„è‰²ï¼Œæ¸©æš–è€Œé¦™ç”œ', position: { x: -3, y: 2, z: -8 }, radius: 0.46, color: 0xffa500, category: 'yellow', name: 'é»„è‰²' }
        ];

        // æ¸¸æˆç±»
        class Game {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);
                this.camera.position.z = 8;
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                this.spheres = [];
                this.mouse = { x: 0, y: 0 };
                this.isDragging = false;
                this.dragStart = null;
                this.rotation = { x: 0, y: 0 };
                this.found = 0;
                this.stats = {};

                this.init();
            }

            init() {
                // æ·»åŠ åæ ‡è½´è¾…åŠ©çº¿
                const axesHelper = new THREE.AxesHelper(15);
                this.scene.add(axesHelper);
                
                // æ·»åŠ ç½‘æ ¼è¾…åŠ©çº¿ - æ›´ç¨€ç–çš„ç½‘æ ¼
                const gridSize = 20;
                const divisions = 5;  // å‡å°‘åˆ†å‰²æ•°ï¼Œä½¿ç½‘æ ¼æ›´ç¨€ç–
                
                // XZå¹³é¢ (åœ°é¢)
                const gridXZ = new THREE.GridHelper(gridSize, divisions, 0x444444, 0x222222);
                gridXZ.material.opacity = 0.3;
                gridXZ.material.transparent = true;
                this.scene.add(gridXZ);
                
                // XYå¹³é¢ (å‰åé¢)
                const gridXY = new THREE.GridHelper(gridSize, divisions, 0x444444, 0x222222);
                gridXY.rotation.x = Math.PI / 2;
                gridXY.material.opacity = 0.3;
                gridXY.material.transparent = true;
                this.scene.add(gridXY);
                
                // YZå¹³é¢ (å·¦å³é¢)
                const gridYZ = new THREE.GridHelper(gridSize, divisions, 0x444444, 0x222222);
                gridYZ.rotation.z = Math.PI / 2;
                gridYZ.material.opacity = 0.3;
                gridYZ.material.transparent = true;
                this.scene.add(gridYZ);
                
                // æ·»åŠ ç¯å…‰
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const light = new THREE.PointLight(0xffffff, 0.8);
                light.position.set(10, 10, 10);
                this.scene.add(light);

                // åˆ›å»ºèƒŒæ™¯
                this.createBackground();

                // åˆ›å»ºçƒä½“ç»„
                this.group = new THREE.Group();
                this.scene.add(this.group);

                // åˆ›å»ºæ‰€æœ‰çƒä½“
                SPHERES.forEach((data, i) => {
                    const mesh = new THREE.Mesh(
                        new THREE.SphereGeometry(data.radius, 32, 32),
                        new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.3, roughness: 0.4 })
                    );
                    mesh.position.set(data.position.x, data.position.y, data.position.z);
                    mesh.userData = { data, found: false, targetColor: new THREE.Color(data.color), currentColor: new THREE.Color(0x808080) };
                    this.group.add(mesh);
                    this.spheres.push(mesh);

                    // æ·»åŠ ä»åŸç‚¹åˆ°æ¯ä¸ªçƒä½“çš„è¿æ¥çº¿
                    const points = [
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(data.position.x, data.position.y, data.position.z)
                    ];
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x404040, 
                        opacity: 0.3, 
                        transparent: true 
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    this.group.add(line);

                    // ç»Ÿè®¡
                    if (!this.stats[data.category]) {
                        this.stats[data.category] = { name: data.name, color: data.color, total: 0, found: 0 };
                    }
                    this.stats[data.category].total++;
                });

                this.updateStats();
                this.setupEvents();
                this.animate();
            }




            

            createBackground() {
                // å…ˆåˆ›å»ºé»˜è®¤æ˜Ÿç©ºèƒŒæ™¯
                const starTexture = this.generateStarBackground();
                const bgGeometry = new THREE.SphereGeometry(50, 60, 40);
                const bgMaterial = new THREE.MeshBasicMaterial({ 
                    map: starTexture, 
                    side: THREE.BackSide 
                });
                this.backgroundMesh = new THREE.Mesh(bgGeometry, bgMaterial);
                this.scene.add(this.backgroundMesh);

                // å¦‚æœé…ç½®äº†å›¾ç‰‡èƒŒæ™¯ï¼Œå°è¯•åŠ è½½
                if (CONFIG.background.image) {
                    const loader = new THREE.TextureLoader();
                    loader.load(
                        CONFIG.background.image,
                        (texture) => {
                            // æˆåŠŸåŠ è½½ï¼Œæ›¿æ¢èƒŒæ™¯
                            console.log('èƒŒæ™¯å›¾ç‰‡åŠ è½½æˆåŠŸ');
                            this.backgroundMesh.material.map = texture;
                            this.backgroundMesh.material.needsUpdate = true;
                        },
                        undefined,
                        (error) => {
                            // åŠ è½½å¤±è´¥ï¼Œä¿æŒæ˜Ÿç©ºèƒŒæ™¯
                            console.log('èƒŒæ™¯å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤æ˜Ÿç©ºèƒŒæ™¯');
                        }
                    );
                }
            }

            generateStarBackground() {
                const canvas = document.createElement('canvas');
                canvas.width = 2048;
                canvas.height = 2048;
                const ctx = canvas.getContext('2d');
                
                // æ¸å˜èƒŒæ™¯
                const grad = ctx.createRadialGradient(1024, 1024, 0, 1024, 1024, 1024);
                grad.addColorStop(0, '#1a2332');
                grad.addColorStop(1, '#050508');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 2048, 2048);
                
                // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                for (let i = 0; i < 500; i++) {
                    ctx.beginPath();
                    ctx.arc(Math.random() * 2048, Math.random() * 2048, Math.random() * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                return new THREE.CanvasTexture(canvas);
            }

            setupEvents() {
                const raycaster = new THREE.Raycaster();
                const mouseVec = new THREE.Vector2();

                document.addEventListener('mousedown', (e) => {
                    this.isDragging = false;
                    this.dragStart = { x: e.clientX, y: e.clientY };
                });

                document.addEventListener('mousemove', (e) => {
                    this.mouse.x = (e.clientX - window.innerWidth / 2) / 100;
                    this.mouse.y = (e.clientY - window.innerHeight / 2) / 100;

                    if (this.dragStart) {
                        const dx = e.clientX - this.dragStart.x;
                        const dy = e.clientY - this.dragStart.y;
                        if (Math.sqrt(dx * dx + dy * dy) > 5) {
                            this.isDragging = true;
                            this.rotation.y += dx * 0.01;
                            this.rotation.x += dy * 0.01;
                            this.dragStart = { x: e.clientX, y: e.clientY };
                        }
                    }
                });

                document.addEventListener('mouseup', () => {
                    this.dragStart = null;
                });

                document.addEventListener('click', (e) => {
                    if (this.isDragging) return;
                    if (e.target.closest('.info-panel') || e.target.closest('.modal')) return;

                    mouseVec.x = (e.clientX / window.innerWidth) * 2 - 1;
                    mouseVec.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    raycaster.setFromCamera(mouseVec, this.camera);

                    const hits = raycaster.intersectObjects(this.spheres);
                    if (hits.length > 0) {
                        const sphere = hits[0].object;
                        if (!sphere.userData.found) {
                            sphere.userData.found = true;
                            sphere.userData.transitioning = true;
                            this.found++;
                            this.stats[sphere.userData.data.category].found++;
                            this.updateStats();
                            
                            console.log('Found:', this.found, '/ 22'); // è°ƒè¯•ä¿¡æ¯
                        }
                        this.showModal(sphere.userData.data);
                    }
                });

                document.querySelector('.close-btn').addEventListener('click', () => {
                    document.getElementById('modal').classList.remove('active');
                });

                document.querySelector('.restart-btn').addEventListener('click', () => {
                    this.restartGame();
                });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            showModal(data) {
                const regularModal = document.getElementById('modal');
                const completionModal = document.getElementById('completion-modal');
                
                // æ£€æŸ¥æ˜¯å¦æ”¶é›†å®Œæ‰€æœ‰çƒä½“
                if (this.found >= SPHERES.length) {
                    console.log('All balls collected! Showing completion modal immediately...'); // è°ƒè¯•ä¿¡æ¯
                    // ç›´æ¥æ˜¾ç¤ºå®Œæˆæ¨¡æ€æ¡†ï¼Œä¸æ˜¾ç¤ºå¸¸è§„æ¨¡æ€æ¡†
                    setTimeout(() => {
                        this.showCompletionModal();
                    }, 100);
                } else {
                    // æ­£å¸¸æ˜¾ç¤ºçƒä½“ä¿¡æ¯
                    document.getElementById('modal-title').textContent = data.title;
                    document.getElementById('modal-description').textContent = data.description;
                    regularModal.classList.add('active');
                }
            }

            showCompletionModal() {
                console.log('Showing completion modal!');
                const modal = document.getElementById('completion-modal');
                if (modal) {
                    modal.classList.add('active');
                    console.log('Modal activated, should be visible now');
                } else {
                    console.error('Completion modal not found!');
                }
            }

            restartGame() {
                // å…³é—­å®Œæˆæç¤º
                document.getElementById('completion-modal').classList.remove('active');

                // é‡ç½®æ‰€æœ‰çƒä½“çŠ¶æ€
                this.found = 0;
                this.spheres.forEach(sphere => {
                    sphere.userData.found = false;
                    sphere.userData.transitioning = true;
                    sphere.userData.currentColor = new THREE.Color(0x808080);
                    sphere.material.color.set(0x808080);
                });

                // é‡ç½®ç»Ÿè®¡
                Object.keys(this.stats).forEach(key => {
                    this.stats[key].found = 0;
                });

                // é‡ç½®æ—‹è½¬
                this.rotation = { x: 0, y: 0 };

                // æ›´æ–°æ˜¾ç¤º
                this.updateStats();
            }

            updateStats() {
                document.getElementById('score').textContent = this.found;
                const container = document.getElementById('colorScores');
                container.innerHTML = '';
                Object.values(this.stats).forEach(stat => {
                    const div = document.createElement('div');
                    div.className = 'color-score-item';
                    div.innerHTML = `
                        <div class="color-dot" style="background-color: #${stat.color.toString(16).padStart(6, '0')}"></div>
                        <div class="color-name">${stat.name}</div>
                        <div class="color-count">${stat.found} / ${stat.total}</div>
                    `;
                    container.appendChild(div);
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                this.camera.position.x += (this.mouse.x - this.camera.position.x) * 0.05;
                this.camera.position.y += (-this.mouse.y - this.camera.position.y) * 0.05;
                this.camera.lookAt(0, 0, 0);

                this.group.rotation.x += (this.rotation.x - this.group.rotation.x) * 0.05;
                this.group.rotation.y += (this.rotation.y - this.group.rotation.y) * 0.05;

                // èƒŒæ™¯è·Ÿéšçƒä½“æ—‹è½¬
                if (this.backgroundMesh) {
                    this.backgroundMesh.rotation.x = this.group.rotation.x;
                    this.backgroundMesh.rotation.y = this.group.rotation.y;
                }

                this.spheres.forEach(s => {
                    s.rotation.x += 0.003;
                    s.rotation.y += 0.005;

                    if (s.userData.transitioning) {
                        s.userData.currentColor.lerp(s.userData.targetColor, 0.1);
                        s.material.color.copy(s.userData.currentColor);

                        const dist = Math.abs(s.userData.currentColor.r - s.userData.targetColor.r) +
                                    Math.abs(s.userData.currentColor.g - s.userData.targetColor.g) +
                                    Math.abs(s.userData.currentColor.b - s.userData.targetColor.b);
                        if (dist < 0.01) s.userData.transitioning = false;
                    }
                });

                this.renderer.render(this.scene, this.camera);
            }
        }

        new Game();
    </script>
</body>
</html>